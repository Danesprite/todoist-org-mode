#!/usr/bin/python
from operator import itemgetter
from dateutil import parser as date_parser
import datetime
from datetime import date
from pytz import timezone
from parse import *

def process_todoist_resources(user_resources):
    """Process Todoist user resources and return a list of project dictionaries"""
    projects = user_resources["projects"]
    items = user_resources["items"] # tasks
    notes = user_resources["notes"] # comments

    # Initialise the items list in each project dictionary
    for project in projects:
        project["items"] = []

    # Initialise the notes list in each item dictionary
    for item in items:
        item["notes"] = []

    # Find all items for each project and add them to the project's dictionary
    for item in items:
        # Find the project
        for project in projects:
            if item["project_id"] == project["id"]:
                # Add this item to the list
                project["items"].append(item)
                break

        # Find all of the notes for this item
        for note in notes:
            if note["item_id"] == item["id"]:
                # Add this note to the list
                item["notes"].append(note)

    # Sort each project's list of tasks on item_order so they are output in the
    # right order. This is necessary because parent IDs of items and projects
    # are not stored, only their indent and order values.
    for project in projects:
        project["items"] = sorted(project["items"], key=itemgetter("item_order"))

    # Do the same for the list of projects and the list of notes for each item
    for item in items:
        # Sort by ID instead of item_order because notes have no item_order
        # attribute
        item["notes"] = sorted(item["notes"], key=itemgetter("id"))

    projects = sorted(projects, key=itemgetter("item_order"))

    # Return the projects as well as the timezone
    return projects, user_resources["user"]["tz_info"]["timezone"]

def process_todoist_projects(projects, my_timezone):
    output_lines = [
        "* Projects",
        "#+CATEGORY: Projects"
    ]

    # Process each project and add the resulting Org lines onto the end of
    # output_lines
    for project in projects:
        output_lines.extend(process_todoist_project(project, my_timezone))

    return output_lines

def process_todoist_project(project, my_timezone, initial_heading_level=1):
    """Translate a Todoist project and return a list of lines to add to the
    output Org file"""
    # Generate the stars using the indent value
    stars = ""
    indent = project["indent"]
    for x in range(0, indent + initial_heading_level): stars += "*"

    output_lines = [
        "%s %s" % (stars, project["name"]),
    ]

    # If this project is the Inbox project, then none of its items are TODOs
    todo = True
    if project["name"] == "Inbox":
        todo = False

    # Process each item
    for item in project["items"]:
        output_lines.extend(process_todoist_item(item, stars, my_timezone, todo))

    return output_lines

def process_todoist_item(item, project_stars, my_timezone, todo=True):
    content = item["content"]
    priority = item["priority"]
    indent = item["indent"]
    due_date_utc = item["due_date_utc"]
    date_string = item["date_string"]
    notes = item["notes"]
    all_day = item["all_day"]
    output_lines = []

    # Generate the stars using the indent value
    stars = project_stars
    for x in range(0, indent): stars += "*"

    # Make an equivalent indentation string using spaces for lines like
    # "  SCHEDULED: <2016-07-22 Fri>"
    spaces = stars.replace("*", " ")

    # Deal with priorities
    priority = {
        4: "[#A] ",
        3: "[#B] ",
        2: "[#C] ",
        # Todoist does not display priority 1 tasks as having any priority
        1: "",
    }[priority]

    # Add lines to the output_lines list
    if todo:
        output_lines.append("%s TODO %s%s" % (stars, priority, content))
    else:
        output_lines.append("%s %s%s" % (stars, priority, content))

    if due_date_utc is not None:
        timestamp = org_timestamp(due_date_utc, date_string, all_day, my_timezone)
        output_lines.append("%s SCHEDULED: %s" % (spaces, timestamp))

    # Text under headings appears to be placed after the lines normally
    # generated by Org mode, such as DEADLINE and SCHEDULED
    # Todoist comments will be placed here
    for note in notes:
        output_lines.append("%s %s" % (spaces, note["content"]))

    output_lines.append("") # Add an empty line after each heading's content
    return output_lines

def org_timestamp(due_date_utc, date_string, all_day, my_timezone):
    # Parse the UTC due date
    dateobj = date_parser.parse(due_date_utc)

    # Convert from UTC to local timezone as set in Todoist settings
    dateobj = dateobj.astimezone(timezone(my_timezone))

    # Don't add the time if the task is an "all-day" task
    if all_day:
        timestamp = dateobj.strftime("<%Y-%m-%d %a>")
    else:
        timestamp = dateobj.strftime("<%Y-%m-%d %a %H:%M>")

    # Transform the timestamp if the current task is recurring
    timestamp = transform_if_recurring(timestamp, date_string)
    return timestamp

def transform_if_recurring(timestamp, date_string):
    date_string = date_string.lower()
    recurring_task_identifiers = [
        "every",
        "daily",
        "weekly",
        "monthly",
        "yearly",
    ]

    # Check if the date_string is indicative of a recurring task
    recurring = False
    for identifier in recurring_task_identifiers:
        if identifier in date_string:
            recurring = True
            break

    if recurring:
        # Remove the ">" on the end of the timestamp
        timestamp = timestamp[0:len(timestamp) - 1]

        # Add an Org repeater using date_string
        timestamp = "%s%s>" % (timestamp, make_org_repeater(date_string))

    return timestamp

def make_org_repeater(date_string):
    # TODO implement this
    # Grammar for Todoist recurring date parsing
    # date: "every" [n] period [at] [time] | recurring_period
    period = ["day", "morning", "evening", "weekday", "days", "week", "month", "year"]
    weekday = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
    # parse("every {}", "every week")
    return ""
